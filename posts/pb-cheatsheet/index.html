<!doctype html><html lang=en><head><meta charset=UTF-8><meta content="IE=edge" http-equiv=X-UA-Compatible><meta content="width=device-width,initial-scale=1.0" name=viewport><title>
        Dynamic Cheatsheets on Pocketbook E-Reader
    </title><link href=/images/favicon.png rel=icon type=image/png><link href=/js/temml/Temml-Local.css rel=stylesheet><script src=https://blog.flxzt.net/js/temml/temml.min.js></script><script src=https://blog.flxzt.net/js/temml/auto-render.min.js></script><script src=https://blog.flxzt.net/node_modules/elevator.js/elevator.min.js></script><link href=https://blog.flxzt.net/node_modules/@fontsource/roboto/latin.css rel=stylesheet><link href=https://blog.flxzt.net/node_modules/@fontsource/merriweather/latin.css rel=stylesheet><link href=https://blog.flxzt.net/node_modules/@fontsource/inconsolata/latin.css rel=stylesheet><script async data-goatcounter=https://flxzt.goatcounter.com/count src=https://blog.flxzt.net/js/count.js></script><noscript><img src="https://flxzt.goatcounter.com//count?p=/posts/pb-cheatsheet/&t=Dynamic Cheatsheets on Pocketbook E-Reader"></noscript><link href=https://blog.flxzt.net/atom.xml rel=alternate title=blog.flxzt.net type=application/atom+xml><link href=https://blog.flxzt.net/theme/light.css rel=stylesheet><link media="(prefers-color-scheme: dark)" href=https://blog.flxzt.net/theme/dark.css rel=stylesheet><link href=https://blog.flxzt.net/main.css media=screen rel=stylesheet><script src=https://blog.flxzt.net/js/main.js></script><body><div class=content><header><div class=site-info><a class=site-title href=https://blog.flxzt.net/>blog.flxzt.net</a><div class=site-description>My personal blog</div></div><nav class=site-menu><a class=site-menu-entry href=/posts>/posts</a><a class=site-menu-entry href=/projects>/projects</a><a class=site-menu-entry href=/tags>/tags</a><a class=site-menu-entry href=/about>/about</a></nav><div class=socials><a class=social href=https://blog.flxzt.net/atom.xml> <img alt=rss src=/social_icons/rss.svg> </a><a class=social href=https://github.com/flxzt/> <img alt=github src=/social_icons/github.svg> </a><a class=social href=https://mastodon.social/@flxzt> <img alt=mastodon src=/social_icons/mastodon.svg> </a></div></header><div class=main-content><main><article><img alt=/posts/pb_cheatsheet/assets/banner.jpg class=banner-image src=https://blog.flxzt.net/processed_images/banner.186725c951b4df9b.jpg><div class=page-title>Dynamic Cheatsheets on Pocketbook E-Reader</div><div class=padded-content><div class=meta><time>2024-05-08</time><span class=tags> <small> <a class=tag href=https://blog.flxzt.net/tags/pocketbook/>pocketbook</a> </small> <small> <a class=tag href=https://blog.flxzt.net/tags/inkview/>inkview</a> </small> <small> <a class=tag href=https://blog.flxzt.net/tags/systemd/>systemd</a> </small> <small> <a class=tag href=https://blog.flxzt.net/tags/dbus/>dbus</a> </small> <small> <a class=tag href=https://blog.flxzt.net/tags/grpc/>grpc</a> </small> <small> <a class=tag href=https://blog.flxzt.net/tags/electronics/>electronics</a> </small> <small> <a class=tag href=https://blog.flxzt.net/tags/embedded/>embedded</a> </small> <small> <a class=tag href=https://blog.flxzt.net/tags/rust/>rust</a> </small> </span></div><div class=tldr-div><strong class=tldr-prefix>tl;dr:</strong> the project sources can be found <a href=https://github.com/flxzt/pb-cheatsheet>here</a></div><div class=toc><h1>Table of Contents</h1><ul><li><a href=https://blog.flxzt.net/posts/pb-cheatsheet/#motivation>Motivation</a><li><a href=https://blog.flxzt.net/posts/pb-cheatsheet/#setup-build-environment>Setup & Build environment</a> <ul><li><a href=https://blog.flxzt.net/posts/pb-cheatsheet/#bindings>Bindings</a><li><a href=https://blog.flxzt.net/posts/pb-cheatsheet/#rooting-ssh>Rooting & SSH</a><li><a href=https://blog.flxzt.net/posts/pb-cheatsheet/#app-transfer>App transfer</a><li><a href=https://blog.flxzt.net/posts/pb-cheatsheet/#debugging>Debugging</a></ul><li><a href=https://blog.flxzt.net/posts/pb-cheatsheet/#inkview-rs-improvements>inkview-rs Improvements</a><li><a href=https://blog.flxzt.net/posts/pb-cheatsheet/#pb-cheatsheet-application>pb-cheatsheet Application</a> <ul><li><a href=https://blog.flxzt.net/posts/pb-cheatsheet/#overview>Overview</a><li><a href=https://blog.flxzt.net/posts/pb-cheatsheet/#host>Host</a></li><ul><li><a href=https://blog.flxzt.net/posts/pb-cheatsheet/#cli>CLI</a><li><a href=https://blog.flxzt.net/posts/pb-cheatsheet/#fetching-info>Fetching Info</a><li><a href=https://blog.flxzt.net/posts/pb-cheatsheet/#service>Service</a></ul><li><a href=https://blog.flxzt.net/posts/pb-cheatsheet/#client>Client</a></li><ul><li><a href=https://blog.flxzt.net/posts/pb-cheatsheet/#persistence>Persistence</a><li><a href=https://blog.flxzt.net/posts/pb-cheatsheet/#dynamic-cheatsheets-using-tags>Dynamic Cheatsheets using Tags</a><li><a href=https://blog.flxzt.net/posts/pb-cheatsheet/#screenshot-feature>Screenshot feature</a></ul><li><a href=https://blog.flxzt.net/posts/pb-cheatsheet/#rpc>RPC</a><li><a href=https://blog.flxzt.net/posts/pb-cheatsheet/#cheatsheets>Cheatsheets</a></ul><li><a href=https://blog.flxzt.net/posts/pb-cheatsheet/#conclusion>Conclusion</a></ul></div><section><h1 id=motivation>Motivation</h1><p>My goal for this project was to repurpose my E-Reader device and write an application that dynamically displays cheatsheets based on the current focused window, acting as a special purpose second screen for mostly static content. The idea was to replace having to print cheatsheets and info cards for often used applications and tools like VSCode, Vim, Bash and so on.<p>Pocketbook E-Reader devices are cool, because their firmware is Linux based and are, in comparison to other devices quite open. They allow creating custom applications in a standard linux environment and additionally Pocketbook's <a href=https://github.com/pocketbook/SDK_6.3.0>own SDK</a> for drawing directly on the display, retrieving input and interacting with their services and utilities.<p>Unfortunately the publicly available SDK seems to not be regularly updated, but it still works on recent firmware. The actual used pocketbook E-Reader is the <a href=https://company.pocketbook.de/de-de/catalog/supportproducts-de/touch-lux3-de>Touch Lux 3</a> (PB626) which is now already quite old but still works fine.<h1 id=setup-build-environment>Setup & Build environment</h1><h2 id=bindings>Bindings</h2><p>The language of choice to write software for me is Rust. The <a href=https://github.com/pocketbook/SDK_6.3.0>SDK</a> is written in C, so there is the need for bindings. Fortunately I am not treading on entirely new territory here. <a href=https://github.com/simmsb>Ben Simms</a> already created <a href=https://github.com/simmsb/inkview-rs>inkview-rs</a>, a bindings crate that does bindings code generation through <a href=https://crates.io/crates/bindgen>bindgen</a> and can be used in combination with <a href=https://github.com/rust-cross/cargo-zigbuild>cargo-zigbuild</a> to dynamically link the SDK with the built application.<p>The bindings code is generated with bindgen's <code>--dynamic-loading</code> flag, so the actual symbols are linked at runtime through the dynamic linker <code>ld</code>. No need to have a complicated build environment with a custom cross-compilation C toolchain for the SDK, linking <code>.a</code> files, and so on!<p>Because of that, remote development really is free of pain. Simply adding the <code>armv7-unknown-linux-gnueabi</code> target to cargo and then executing <code>cargo zigbuild --target armv7-unknown-linux-gnueabi.2.23</code> cross-compiles to <code>armv7</code> with a specific glibc version that matches the one present on the Pocketbook device.<h2 id=rooting-ssh>Rooting & SSH</h2><p>By default it is not possible to run programs with root permissions on the device. However, because the firmware uses an old kernel version that is vulnerable to the "Mad-COW" exploit it is possible to "jailbreak" and install a root shell. The <code>pbjb</code> application has a guide in the "low-level-internals" section in the <a href="https://www.mobileread.com/forums/showthread.php?t=325185">mobileread forum thread</a> to do that. After that programs with root permissions can be launched through <code>/mnt/secure/su</code>.<p>Now I could launch a SSH server with a script <code>ssh-dropbear.app</code> that executes <code>dropbear</code> like:<pre class=language-sh data-lang=sh style=color:#bfbab0;background-color:#0f1419><code class=language-sh data-lang=sh><span style=color:#5c6773;font-style:italic>#!/bin/sh
</span><span style=color:#ffb454>/mnt/secure/su</span><span> /sbin/dropbear</span><span style=color:#f29718> -p</span><span> 2468</span><span style=color:#f29718> -G </span><span style=color:#c2d94c>""
</span></code></pre><p>The installed dropbear version does not accept all key algorithms though, I personally had trouble connecting at first. After some research, I came up with this SSH config that should work in most cases:<pre style=color:#bfbab0;background-color:#0f1419><code><span>Host pocketbook
</span><span>  HostName &lt;device-ip>
</span><span>  Port 2468
</span><span>  User root
</span><span>  HostKeyAlgorithms +ssh-rsa
</span><span>  PubKeyAcceptedAlgorithms +ssh-rsa
</span><span>  PubkeyAuthentication=no
</span><span>  StrictHostKeyChecking=no
</span></code></pre><p>The SSH server should not be launched when the device is connected to non-trusted networks though because anyone could connect to it as root without any authentication.<h2 id=app-transfer>App transfer</h2><p>Applications with the file suffix <code>.app</code> placed into the <code>/mnt/ext1/applications</code> directory (that appears as only <code>applications</code> when the device is connected through USB) are automatically shown in the applications launcher. They can be binaries but also shell scripts. This is very useful to create some tools to make the development easier.<p>To iterate fast I wanted to be able to transfer the built application to the device without any physical tasks like plugging a USB-cable in and out.<p>To do that I utilized <code>netcat</code>, a tool for creating ad-hoc network sockets and transmit arbitrary data over them. The tool is already present on the device, so I only needed to create scripts for the developer machine & device that send and receive applications.<div style="grid-template-columns:50% 50%;column-gap:12px;display:grid"><div style=grid-column:1>Sender: <pre class=language-sh data-lang=sh style=color:#bfbab0;background-color:#0f1419><code class=language-sh data-lang=sh><span style=color:#f07178>echo </span><span style=color:#c2d94c>"Sending application name.."
</span><span style=color:#f07178>echo </span><span style=color:#f29668>&lt;</span><span>app-name</span><span style=color:#f29668>> | </span><span style=color:#ffb454>nc </span><span style=color:#f29668>&lt;</span><span>device-ip</span><span style=color:#f29668>> </span><span style=color:#f29718>19991
</span><span style=color:#5c6773;font-style:italic># The e-reader needs a bit of time to re-launch 'nc'
</span><span style=color:#ffb454>sleep</span><span> 3
</span><span style=color:#f07178>echo </span><span style=color:#c2d94c>"Sending application content.."
</span><span style=color:#ffb454>nc </span><span style=color:#f29668>&lt;</span><span>device-ip</span><span style=color:#f29668>> </span><span style=color:#f29718>19991 </span><span style=color:#f29668>&lt;</span><span> /local/path/to/binary
</span></code></pre></div><div style=grid-column:2>Receiver: <pre class=language-sh data-lang=sh style=color:#bfbab0;background-color:#0f1419><code class=language-sh data-lang=sh><span style=color:#f07178>echo </span><span style=color:#c2d94c>"Listening for application name.."
</span><span>LOCAL_APP_NAME</span><span style=color:#f29668>=</span><span style=color:#c2d94c>$</span><span>(</span><span style=color:#ffb454>nc</span><span style=color:#f29718> -l -p</span><span style=color:#c2d94c> 19991 </span><span style=color:#f29668>| </span><span style=color:#ffb454>tr</span><span style=color:#f29718> -d </span><span style=color:#c2d94c>' '</span><span>)
</span><span style=color:#f07178>echo </span><span style=color:#c2d94c>"Received application name : '$</span><span>LOCAL_APP_NAME</span><span style=color:#c2d94c>'"
</span><span>LOCAL_APP_PATH</span><span style=color:#f29668>=</span><span style=color:#c2d94c>"/mnt/ext1/applications/$</span><span>LOCAL_APP_NAME</span><span style=color:#c2d94c>"
</span><span style=color:#f07178>echo </span><span style=color:#c2d94c>"Listening for application content.."
</span><span style=color:#ffb454>nc</span><span style=color:#f29718> -l -p</span><span> 19991 </span><span style=color:#f29668>> </span><span style=color:#c2d94c>"$</span><span>LOCAL_APP_PATH</span><span style=color:#c2d94c>"
</span><span style=color:#f07178>echo </span><span style=color:#c2d94c>"Application has been saved to '$</span><span>LOCAL_APP_PATH</span><span style=color:#c2d94c>'"
</span></code></pre></div></div><h2 id=debugging>Debugging</h2><p>I also wanted to debug remotely with gdb. This is possible by: in a SSH session, launching a <code>gdbserver</code> session with command <code>gdbserver 0.0.0.0:10003 /mnt/ext1/applications/&lt;app-name>.app</code>.<p>On the developer machine when using vscode for development, the extension 'CodeLLDB' can be used for debugging Rust code. A <code>launch.json</code> configuration entry ended up looking like this:<pre class=language-json data-lang=json style=color:#bfbab0;background-color:#0f1419><code class=language-json data-lang=json><span>{
</span><span>    </span><span style=color:#c2d94c>"type"</span><span style=color:#bfbab0cc>: </span><span style=color:#c2d94c>"lldb"</span><span style=color:#bfbab0cc>,
</span><span>    </span><span style=color:#c2d94c>"request"</span><span style=color:#bfbab0cc>: </span><span style=color:#c2d94c>"custom"</span><span style=color:#bfbab0cc>,
</span><span>    </span><span style=color:#c2d94c>"name"</span><span style=color:#bfbab0cc>: </span><span style=color:#c2d94c>"remote debug &lt;app-name>"</span><span style=color:#bfbab0cc>,
</span><span>    </span><span style=color:#c2d94c>"targetCreateCommands"</span><span style=color:#bfbab0cc>: </span><span>[
</span><span>        </span><span style=color:#c2d94c>"target create ${workspaceFolder}/target/armv7-unknown-linux-gnueabi/debug/examples/&lt;app-name>"
</span><span>    ]</span><span style=color:#bfbab0cc>,
</span><span>    </span><span style=color:#c2d94c>"processCreateCommands"</span><span style=color:#bfbab0cc>: </span><span>[
</span><span>        </span><span style=color:#c2d94c>"gdb-remote &lt;device-ip>:10003"
</span><span>    ]
</span><span>}
</span></code></pre><p>Now I could step through code, set breakpoints and so on. Of course it's also possible to use the gdb CLI directly.<h1 id=inkview-rs-improvements>inkview-rs Improvements</h1><p>The <code>inkview-rs</code> bindings crate needed additional features and fixes to satisfy my needs. For one, it needed to be extended to the SDK version <code>v5.19</code> that is supported on the Touch Lux 3. Previously, only bindings for <code>v6.5</code> were generated. These API versions can now be switched through cargo features <code>sdk-5-19</code> and <code>sdk-6-5</code> at compile time.<p>I added additional safe rust wrappers for common tasks like a fast screen update and a wrapper for the dialog API. The library also previously had issues with an vertical draw offset which could be fixed by an setting a specific application flag through the pocketbook SDK.<p>Additionally I added an adapter crate <code>inkview-eg</code> which implements the <a href=https://docs.rs/embedded-graphics-core/latest/embedded_graphics_core/draw_target/trait.DrawTarget.html>embedded_graphics::DrawTarget</a> trait for the display. Doing that enables drawing with convenient API for graphics primitives and even things like text and bitmap images.<h1 id=pb-cheatsheet-application>pb-cheatsheet Application</h1><h2 id=overview>Overview</h2><p>Establishing a solid development environment and improvements to the inkview-rs library took a few weeks while working on-and-off on it. But after that I could focus on the application itself. The code is entirely open-source under 'GPLv3' and can be found <a href=https://github.com/flxzt/pb-cheatsheet>here</a><p>The host side is a CLI tool that is able to communicate with the GRPC server of the client. It should have the following features:<ul><li>ability to upload cheatsheets (images) to the client<li>register/delete associated tags<li>retrieve device state<li>ability to take screenshots and automatically upload them to the client<li>continuously report the current focused window</ul><p>The client is a pocketbook specific application that holds and manages state and draws to the screen. For communication with the host it starts a GRPC server. It should be possible to display some stats like the reported focused window by pressing the <code>Menu</code> button. There should also be three distinct modes as UI:<ul><li><code>Manual</code> : the user can manually cycle through the uploaded cheatsheets<li><code>Automatic WM-Class</code> : display cheatsheets for which tags are registered that match with the tags registered to the reported focused window class.<li><code>Screenshot</code> : display the last uploaded screenshot</ul><p>Now let's get into the details of how all of this is actually implemented.<h2 id=host>Host</h2><h3 id=cli>CLI</h3><p>The following commands are implemented:<pre style=color:#bfbab0;background-color:#0f1419><code><span>Usage: pb-cheatsheet-host --pb-grpc-addr &lt;PB_GRPC_ADDR> &lt;COMMAND>
</span><span>
</span><span>Commands:
</span><span>  report-focused-window   Continuously report focused window info to the client.
</span><span>                               Intended to be run as a service
</span><span>  get-screen-info         Get device screen info
</span><span>  get-cheatsheets-info    Get cheatsheets info
</span><span>  upload-cheatsheet       Upload a new cheatsheet that gets displayed when the added tags match the tags
</span><span>                               that are added to the wm class of the reported window.
</span><span>                               The image size is adjusted depending on the reported screen info of the client
</span><span>  remove-cheatsheet       Remove a cheatsheet
</span><span>  screenshot              Take a screenshot and upload it to the device for transient display
</span><span>  clear-screenshot        Clear the screenshot
</span><span>  add-cheatsheet-tags     Add cheatsheet tags
</span><span>  remove-cheatsheet-tags  Remove cheatsheet tags
</span><span>  add-wm-class-tags       Add wm class tags
</span><span>  remove-wm-class-tags    Remove wm class tags
</span><span>  help                    Print this message or the help of the given subcommand(s)
</span></code></pre><p>For example the output when fetching cheatsheet info looks like this:<p><img alt=./assets/host-get-cheatsheets-info.png src=https://blog.flxzt.net/posts/pb-cheatsheet/./assets/host-get-cheatsheets-info.png><h3 id=fetching-info>Fetching Info</h3><p>Retrieving the focused window is implemented only for the Gnome desktop environment, because unfortunately there is no universal Wayland protocol yet that would enable a desktop environment independent implementation.<p>The Gnome extension <a href=https://github.com/flexagoon/focused-window-dbus>focused-window-dbus</a> must also be installed. It reports the focused window through a DBus interface.<p>The host application uses <a href=https://crates.io/crates/zbus>zbus</a> to fetch this info from the extension. The core Rust code to do that looks like this:<pre class=language-rust data-lang=rust style=color:#bfbab0;background-color:#0f1419><code class=language-rust data-lang=rust><span style=color:#bfbab0cc>#</span><span>[</span><span style=color:#ffb454>proxy</span><span>(
</span><span>    default_service </span><span style=color:#f29668>= </span><span style=color:#c2d94c>"org.gnome.Shell"</span><span style=color:#bfbab0cc>,
</span><span>    default_path </span><span style=color:#f29668>= </span><span style=color:#c2d94c>"/org/gnome/shell/extensions/FocusedWindow"</span><span style=color:#bfbab0cc>,
</span><span>    interface </span><span style=color:#f29668>= </span><span style=color:#c2d94c>"org.gnome.shell.extensions.FocusedWindow"
</span><span>)]
</span><span style=color:#f73>trait </span><span style=color:#59c2ff>FocusedWindow </span><span>{
</span><span>    async </span><span style=color:#f73>fn </span><span style=color:#ffb454>get</span><span>(</span><span style=color:#f29668>&</span><span style=color:#f29718>self</span><span>) </span><span style=color:#bfbab0cc>-> </span><span style=color:#39bae6;font-style:italic>Result</span><span>&lt;</span><span style=color:#39bae6;font-style:italic>String</span><span>></span><span style=color:#bfbab0cc>;
</span><span>}
</span><span>
</span><span style=color:#f73>pub</span><span>(</span><span style=color:#f73>crate</span><span>) async </span><span style=color:#f73>fn </span><span style=color:#ffb454>get_focused_window_info</span><span>&lt;</span><span style=color:#f73>'a</span><span>>(
</span><span>    </span><span style=color:#f29718>connection</span><span style=color:#bfbab0cc>: </span><span style=color:#f29668>&</span><span>Connection,
</span><span>) </span><span style=color:#bfbab0cc>-> </span><span>anyhow</span><span style=color:#f29668>::</span><span style=color:#39bae6;font-style:italic>Result</span><span>&lt;FocusedWindowInfo> {
</span><span>    </span><span style=color:#f73>let</span><span> proxy </span><span style=color:#f29668>= </span><span>FocusedWindowProxy</span><span style=color:#f29668>::</span><span>new(connection)</span><span style=color:#f29668>.</span><span>await</span><span style=color:#f29668>?</span><span style=color:#bfbab0cc>;
</span><span>    </span><span style=color:#f73>let</span><span> val</span><span style=color:#bfbab0cc>: </span><span>serde_json</span><span style=color:#f29668>::</span><span>Value </span><span style=color:#f29668>= </span><span>serde_json</span><span style=color:#f29668>::</span><span>from_str(</span><span style=color:#f29668>&</span><span>proxy</span><span style=color:#f29668>.</span><span style=color:#f07178>get</span><span>()</span><span style=color:#f29668>.</span><span>await</span><span style=color:#f29668>?</span><span>)</span><span style=color:#f29668>?</span><span style=color:#bfbab0cc>;
</span><span>    </span><span style=color:#5c6773;font-style:italic>// ...
</span><span>}
</span></code></pre><h3 id=service>Service</h3><p>The <code>pb-cheatsheet-host report-focused-window</code> command continuously fetches info about the current focused window and reports it to the client over GRPC when it changes.<p>This command can be a service that is started by systemd. A suitable <code>.service</code> file:<pre class=language-toml data-lang=toml style=color:#bfbab0;background-color:#0f1419><code class=language-toml data-lang=toml><span>[</span><span style=color:#59c2ff>Unit</span><span>]
</span><span style=color:#59c2ff>Description</span><span>=</span><span style=color:#c2d94c>"pb-cheatsheet-host focused window reporter"
</span><span style=color:#59c2ff>StartLimitIntervalSec</span><span>=</span><span style=color:#f29718>0
</span><span style=color:#59c2ff>StartLimitBurst</span><span>=</span><span style=color:#f29718>0
</span><span>
</span><span>[</span><span style=color:#59c2ff>Service</span><span>]
</span><span style=color:#59c2ff>Environment</span><span>=</span><span style=color:#c2d94c>"PB_GRPC_ADDR=&lt;client-ip:51151>"
</span><span style=color:#59c2ff>Environment</span><span>=</span><span style=color:#c2d94c>"RUST_LOG=pb-cheatsheet-host=&lt;log-level>"
</span><span style=color:#59c2ff>ExecStart</span><span>=</span><span style=color:#f33>%h/.cargo/bin/pb-cheatsheet-host report-focused-window
</span><span style=color:#59c2ff>Restart</span><span>=</span><span style=color:#f33>on-failure
</span><span style=color:#59c2ff>RestartSec</span><span>=</span><span style=color:#f29718>30
</span><span>
</span><span>[</span><span style=color:#59c2ff>Install</span><span>]
</span><span style=color:#59c2ff>WantedBy</span><span>=</span><span style=color:#f33>default.target
</span></code></pre><h2 id=client>Client</h2><p>The client starts a GRPC server listening to incoming procedure call requests and messages.<p>It does that in an asynchronous task, which sends messages over a channel to the handler. This handler also receives incoming messages from the pocketbook event main loop. Because the pocketbook SDK is not designed to be used in an async context, both "worlds", async and blocking, have to be combined carefully.<p>The client also holds some state about the cheatsheets, their tags and the UI.<h3 id=persistence>Persistence</h3><p>The cheatsheets and the metadata containing the tags are saved as files whenever changes are made and when the app is closed. The populated save directory looks like this:<pre class=language-bash data-lang=bash style=color:#bfbab0;background-color:#0f1419><code class=language-bash data-lang=bash><span style=color:#ffb454>save_dir/
</span><span>  </span><span style=color:#ffb454>wm_class_tags.json </span><span style=color:#5c6773;font-style:italic># JSON file containing the tags that are associated with windows
</span><span>  </span><span style=color:#ffb454>cheatsheet_app_1.cs </span><span style=color:#5c6773;font-style:italic># Raw cheatsheet image data about &lt;app1>
</span><span>  </span><span style=color:#ffb454>cheatsheet_app_1.json </span><span style=color:#5c6773;font-style:italic># Metadata about &lt;app1> cheatsheet containing associated tags
</span><span>  </span><span style=color:#5c6773;font-style:italic># ..
</span></code></pre><p>The metadata is saved as <code>json</code> with <a href=https://crates.io/crates/serde>serde</a> and <a href=https://crates.io/crates/serde_json>serde_json</a>.<p>For the cheatsheets images serde and <a href=https://crates.io/crates/bincode>bincode</a> is used for maximizing efficiency for raw image data. The images themselves are pre-converted to 8-bit grayscale and scaled the client display resolution on the host.<h3 id=dynamic-cheatsheets-using-tags>Dynamic Cheatsheets using Tags</h3><p>The tags system works like this:<p><a href=https://blog.flxzt.net/posts/pb-cheatsheet/./assets/client-tags-diagram.svg><img alt src=https://blog.flxzt.net/posts/pb-cheatsheet/./assets/client-tags-diagram.svg></a><p>Every window class is associated with different tags grouping different cheatsheets. For every tag that matches, the corresponding cheatsheet is displayed. The user is able to cycle through them with the <code>Prev</code>/<code>Next</code> buttons.<h3 id=screenshot-feature>Screenshot feature</h3><video controls=controls width=100%><source src=/posts/pb-cheatsheet/assets/client-screenshot.mp4 type=video/mp4></video><p>The host uses the <a href=https://flatpak.github.io/xdg-desktop-portal/docs/doc-org.freedesktop.portal.Screenshot.html>XDG Desktop Screenshot Portal</a> to open the screenshot tool and fetch the save path. It then reads the image data from the path, prepares and sends it to the client. The client then automatically switches to the <code>Screenshot</code> UI mode and displays that image. For users of dark mode UI's, there is the possibility to invert the screenshot colors with a flag.<h2 id=rpc>RPC</h2><p>For communication and remote procedure calls between host and client <a href=https://grpc.io/>GRPC</a> is used. The protocol is specified in a protobuf <code>.proto</code> file. A snippet:<pre class=language-proto data-lang=proto style=color:#bfbab0;background-color:#0f1419><code class=language-proto data-lang=proto><span style=color:#f73>syntax </span><span style=color:#f29668>= </span><span style=color:#c2d94c>"proto3"</span><span style=color:#bfbab0cc>;
</span><span style=color:#f73>package </span><span style=color:#59c2ff>pb_cheatsheet</span><span style=color:#bfbab0cc>;
</span><span>
</span><span style=color:#f73>service </span><span style=color:#59c2ff>PbCheatsheet </span><span>{
</span><span>  </span><span style=color:#f73>rpc </span><span style=color:#ffb454>FocusedWindow</span><span>(FocusedWindowInfo) </span><span style=color:#f73>returns </span><span>(Empty) {}
</span><span>  </span><span style=color:#f73>rpc </span><span style=color:#ffb454>GetScreenInfo</span><span>(Empty) </span><span style=color:#f73>returns </span><span>(ScreenInfo) {}
</span><span>  </span><span style=color:#f73>rpc </span><span style=color:#ffb454>GetCheatsheetsInfo</span><span>(Empty) </span><span style=color:#f73>returns </span><span>(CheatsheetsInfo) {}
</span><span>  </span><span style=color:#f73>rpc </span><span style=color:#ffb454>UploadCheatsheet</span><span>(UploadCheatsheetRequest) </span><span style=color:#f73>returns </span><span>(Empty) {}
</span><span>  </span><span style=color:#5c6773;font-style:italic>// ...
</span><span>}
</span><span>
</span><span style=color:#5c6773;font-style:italic>// ...
</span></code></pre><p>The <a href=https://crates.io/crates/tonic>tonic</a> crate generates Rust code for client and server out of it.<h2 id=cheatsheets>Cheatsheets</h2><p>To create cheatsheets easily there is a typst template that is optimized for 'keyboard-key' -> 'functionality' pair lists, uses an E-Paper suitable font and scales it's content for the lower resolution while reducing margins to maximize available space.<p>A snippet how this template is used for a git cheatsheet:<pre class=language-typst data-lang=typst style=color:#bfbab0;background-color:#0f1419><code class=language-typst data-lang=typst><span>#import "./cheat-template.typ": cheat
</span><span>
</span><span>#show: cheat.with(
</span><span>  title: [Git Cheatsheet],
</span><span>  icon: image("icons/git.svg"),
</span><span>)
</span><span>
</span><span>#table(
</span><span>  table.header[Adding changes],
</span><span>  [`git add -u &lt;path>`], [Add all tracked files to the *staging area*.],
</span><span>  [`git add -p &lt;path>`], [Interactively pick which files to *stage*],
</span><span>)
</span><span>
</span><span>// ..
</span></code></pre><p>The rendered image looks like this:<p><a href=https://blog.flxzt.net/posts/pb-cheatsheet/./assets/cheat-git.png><img alt src=https://blog.flxzt.net/posts/pb-cheatsheet/./assets/cheat-git.png></a><h1 id=conclusion>Conclusion</h1><p>It was a lot of work, but I gained a lot of knowledge about creating a development environment and the additional hurdles when developing for remote embedded linux systems. Generating bindings that do dynamic linking and using 'zigbuild' stand out as very useful tools to avoid most of the pain of that would come with a 'regular' cross-build setup.<p>I also really enjoyed using GRPC as the remote procedure call mechanism between host and client. It seems very efficient, well thought out with regards to forward and backwards compatibility, stable and on top of it, was also quite easy and enjoyable to work with. So it will be one of my first choices in future projects that need to do RPC.<p>I think this turned out pretty well, I achieved basically all of the goals for features that I had planned before I started.</section></div></article></main></div><footer><small> Felix Zwettler - <a href=http://creativecommons.org/licenses/by-sa/4.0/ rel=license><img alt="Creative Commons Lizenzvertrag" src=https://i.creativecommons.org/l/by-sa/4.0/80x15.png></a> - Â© 2025 </small></footer><button class=elevator-button>ðŸ›—</button></div></body><script src=https://blog.flxzt.net/js/temml_config.js></script>